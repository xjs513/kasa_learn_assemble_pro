##  概述

语言  进制  进制如何运算  二进制   数据宽度

***

有符号数和无符号数  原码反码补码  位运算

---

汇编  寄存器  内存  汇编指令

---

内存复制  堆栈的指令  汇编如何写函数

堆栈传参  堆栈平衡    外挂

***

重点学习思路而不是内容

####  语言

沟通的桥梁

####   什么是机器语言  

最早的程序员：穿孔卡带

```
0 和 1
```

####  什么是汇编语言

复杂的机器语言能简化么？助记符  ==》 汇编语言 =编译器=》 机器语言

```
加 INC 0100 0000
减 DEC 0100 1000
乘 MUL 0100 1000 0100 1000
除 DIV 0100 1000 1100 1000
```

如果不懂底层原理，那么我们离程序的本质就有隔阂！

 汇编一般用于底层 的编写、单片机开发等等。

汇编再进行简化就变成了 C 语言

```shell
加 A+B 0100 0000
减 A-B 0100 1000
乘 A*B 0100 1000 0100 1000
除 A/B 0100 1000 1100 1000
```

![image-20200713164319654](C:\工作资料\笔记资料\2020-大数据起航\chengxuyuanbishilian.png)

####  机制怎么运算

运算的本质就是查数

```shell
# 八进制计算以下结果
2 + 3 = 5
2 * 3 = 6
4 + 5 = 11
4 * 5 = 24
# 运算的本质就是查数
0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27
```

每种进制都有对应的加法表和乘法表  

运行=》calc 调出计算器程序

每种进制都是完美的~！不需要通过十进制来进行沟通运算！！

####  为什么要学习理解二进制

寄存器、内存、位！底层的每一位都是有含义的。汇编入门理解的基础！

汇编高级：了解程序的深层！操作系统的内核？

####  数据宽度

计算机：内存 ！给数据增加数据 宽度

```shell
bit Byte Word(字16位) DWord(双字32位)
```

C、C++ 和 Java 都需要定义数据的类型。

因为 计算机底层需要在内存中定义数据的宽度。

####  有符号数和无符号数

数据都是有宽度的。每个数据代表什么意思呢？二进制： 01010101

规则，二进制解码规则？

- 无符号数规则

  ```shell
  1001 1010  十六进制：0x9A  十进制：154
  ```

- 有符号数规则

  最高位表示符号位 ：0（正数）， 1（负数）

###  原码反码补码

- 计算机内只有补码，原码反码是帮助人类理解的
- 正数的原码反码补码都一样
- 负数
  - 源码：符号位不变，其余不变 
  - 反码：符号位不变，其余位取反
  - 补码：反码 + 1

==如果看到一个二进制数字，首先要确定是有符号数还是无符号数==

####  寄存器

一般电脑有8个通用寄存器，可以存值  

```shell
mov eax  1 # 把 1放入寄存器eax中  => EAX 0000 0001
mov eas -1 # 把-1放入寄存器eax中  => EAX FFFF FFFF
```

####  位运算 四种 and or xor not

计算机可以存储、计算所有的数字(正数、浮点数、字符)。！

2*8 最高效计算方式？？

很多底层的调试器，需要通过位来判断CPU的状态。

##### 与运算（and &）

两个都为1，结果才为1

```shell
1011 0001
1101 1000
----------& and
1001 0000
```

#####  或运算（or |）

只要有一个1，结果就为1

```shell
1011 0001
1101 1000
----------| or
1111 1001
```

##### 异或运算（xor ^）

不一样就是亮！！！

```shell
1011 0001
1101 1000
----------^ xor
0110 1001
```

##### 非运算（not ~） 单目运算符

按位取反即可！！

```shell
1101 1000
----------~ not
0010 0111
```

==通过位运算可以实现加减乘除==

####  移位运算

#####  左移(shl >>)

```shell
0000 0001 @ 所有二进制位全部左移若干位, 高位丢弃, 低位补0
0000 0010
```

##### 右移(shr >>)

```shell
0000 0001 @ 所有二进制位全部右移若干位, 低位丢弃, 高位补0还是1由符号位决定
0000 0010
```

####  位运算的加减乘除

四则运算是数学运算的基础，而加法又是四则运算的基础  4 + 5 = ？

==计算机只会加法！！==

```shell
# 计算机不会直接加
# 计算机的实现原理
# 第一步：异或运算 如果不考虑进位，异或可以直接出结果
0000 0100
0000 0101
----------  xor
0000 0001
# 第二步：与运算，判断进位，如果结果为0，则表示没有进位
0000 0100
0000 0101
----------  and
0000 0100
# 第三步：将与运算的结果左移一位 
0000 0100
----------  <<
0000 1000  ##  进位的结果
# 第四步：继续异或运算  将异或的结果和进位的结果继续进行异或运算
0000 0001
0000 1000
----------  xor
0000 1001
# 第五步：继续与运算，判断进位，如果结果为0，则表示没有进位
0000 0001
0000 1000
----------  and
0000 0000
# 所以最终结果就是与运算结果为0的上一个异或运算的结果！！！
```

#  汇编语言

通过指令来代替我们的二进制编码！！！

通过汇编指令可以给计算机发一些操作，然后让计算机执行。

编译器的发展，底层的大佬，几乎都是最原始 的IDE。

学习汇编，需要先掌握环境的配置

1. VC6 程序到汇编的理解
2. OD  反汇编工具 ==四个区域 汇编 寄存器   内存  堆栈==
3. 抓包工具
4. 加密解密工具

学汇编(3天)不是为了写代码，是为了理解程序的本质。

汇编有三个很重要的东西：寄存器 内存 汇编指令

###  通用寄存器

==可以存任意的值==

存储数据：CPU(寄存器) > 内存 > 硬盘

32 位系统的通用寄存器只有 8 个  0000 0000 - FFFF FFFF

```shell
EAX EBX ECX EDX
EBP ESP EDI ESI
```

寄存器如何存值？mov 指令

```
mov 存的地址  存的数据/地址
```

不同系统的寄存器

```shell
32位    16位     8位
EAX		AX		AL
ECX		CX		CL
EDX		DX		DL
EBX		BX		BL
ESP		SP		AH
EBP		BP		CH
ESI		SI		DH
EDI		DI		BH
```

8 位：L代表低8位，H代表高8位

![image-20200714144347748](C:\Users\hds\AppData\Roaming\Typora\typora-user-images\image-20200714144347748.png)

除了通用寄存器外，其他的寄存器都有特定的功能！！

###  内存

寄存器很小，不够用，所以需要把数据放到内存中！

32位的寻址能力最大是 4GB！

FFFF FFFF + 1 = 1 0000 0000 * 8 = 8 0000 0000 bit 这里是十六进制的

字节数用十六进制表示： 1 0000 0000

转换为十进制：4,294,967,296  Byte

4,294,967,296 / 1024 = 4,194,304 KB

4,194,304 / 1024 = 4,096 MB

4,096 / 1024 = 4GB

***

64 位的寻址能力最大是 ?? GB！64位中有16位是保留位

所以只有38位用来寻址

3F FFFF FFFF + 1 = 40 0000 0000 Byte

转换为十进制：274,877,906,944  Byte

274,877,906,944 / 1024 = 268,435,456 KB

268,435,456 / 1024 = 262,144 MB

262,144 / 1024 = ==256 GB==

---

所以每个内存空间都有一个编号，即内存地址，通过地址寻找对应的内存空间。

内存如何存值？

mov 指令  

数据宽度：byte word dword qword

地址的位置：0xFFFFFFFF

不是任意的地址都可以写值，只有申请过的内存才可以使用。

```shell
move byte ptr ds:[0019FF70],1
```

内存地址有多种写法

ds:[0019FF70 + 4]

ds:[eax]

ds:[eax + 4]