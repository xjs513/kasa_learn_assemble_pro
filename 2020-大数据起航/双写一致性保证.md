##  问题

如何保证缓存和数据库的双写一致性  ??

## 分析

如果采用了缓存来提高系统并发读性能，那么写数据的时候就会有数据一致性问题

一般来说，如果系统不严格要求缓存+数据库必须一致的话，

缓存可以接受和数据库偶尔稍微不一致的情况，那么不要采用下面的方案：

读请求和写请求串行化到一个内存队列中去，这样就能保证双写一致性。

串行化之后，会使系统吞吐量大幅降低，会使用更多的机器来满足需要的吞吐量。

------

一般实时性要求比较高的那块数据会做缓存，比如电商的库存服务。

库存更新的时候，要同时更新缓存，缓存数据清理或过期后，会从库里读数据并填充缓存。

##  解决方案：

1.  最初级的缓存不一致问题以及解决方案

   问题：先写一个，再写另一个在单线程下都有明显缺陷，不再赘述。

   解决思路：先删除缓存，成功后再修改数据库。

   如果修改数据库失败了，那么数据是旧的，缓存为空，数据不会不一致。

   ==这是在单线程的情况下==

2. 比较复杂的数据不一致问题分析  在 1 的基础上考虑并发

   数据变更时，**先删缓存在更新数据库**，在删除成功修改未进行的时候，

   一个读数据请求过来，发现缓存为空，去读库填充缓存

   然后更新数据的请求完成了数据库的更新操作

   ==这时数据库和缓存的数据已经不一致了！！！==

3. 为什么高并发场景下，缓存会出现这个问题

   只有在对一个数据进行高并发读写的时候，才可能出现该问题。

4. 更新与读取操作进行**异步串行化**处理

   更新数据时，更新数据唯一标识，路由到一个 JVM 内部的队列中。

   读取数据的时候，如果发现数据不在缓存，那么把重新读取+更新缓存的操作，

   也路由到同一个 JVM 内部的同一个队列中。

   一个队列对应一个工作线程，该线程逐条拿到对应操作，串行处理。

   这样的话，如果再发生2中的情况，即变更操作执行一半时进来了取请求，

   那么这两个操作将在同一个JVM的同一个队列中被工作线程串行处理。

   等队列对应的工作线程完成了上一个操作的数据库更新后，才会执行下一个操作，

   也就是更新缓存的操作，此时会从数据库中读取最新数据填充缓存。

   ==相同的商品ID，进行 hash 取值，对内存队列数量取模，这样都能路由到某个内存队列==

   ==这个过程应该很快，删除缓存+更新数据库的操作一般在20MS内完成==

   ==读数据库+更新缓存的操作一般也在20MS内完成，读请求会卡顿40MS左右==

   优化：

   短时间内多个读请求的话，判断对这个商品的读取操作而言，如果之前缓存中最后是读操作，

   那么不用再压到队列中串行处理，读请求hang住200MS然后读缓存，有就直接返回，

   没有就从数据库中读取后直接返回，不更新缓存。

5. 高并发场景下该方案要注意的问题

   1.读请求长时间阻塞

   由于读请求进行了非常轻度的异步化处理，一定要注意读超时问题，必须在超时时间范围内返回。

   该解决方案最大的风险点在于：可能数据更新很频繁，导致队列中积压了大量更新操作，然后

   读请求会发生大量的超时，导致这些请求都直接走了数据库。

   务必进行一些真实的测试，观察更新数据的频率是怎样的。

   另外，因为队列中可能积压针对多个数据项的更新操作，需要根据自身业务情况进行测试，

   可能要部署多个服务，每个服务分摊一些数据的更新操作。

   实际根据项目经验，数据的更新频率一般较低，因此积压的更新操作应该较少。

   一般的真实情况是：

   大量的读请求都是从缓存直接获取数据，

   少量的读请求遇到数据更新冲突，这时需要走上面介绍的**异步串行化**处理流程 。

   等数据更新完了 ，读请求触发的缓存更新也完成，然后临时等待的请求都可以从缓存直接取数据。

   2.读请求并发过高

   风险：突然大量读请求会在几十毫秒的延时 hang 在服务上，看服务能否抗住，需要多少机器才能抗住峰值。

   但是因为并不是所有数据都在同一时间更新，缓存也不会同一时间失效，

   所以每次可能就是少数缓存失效，对应数据的读请求并发量也应不大。

   按 1:99 的比例计算读与写的请求，每秒5万的QPS，可能只有500次更新操作。

   3.多服务实例部署的请求路由

   可能这个服务器部署了多个服务实例，那么必须保证：

   执行数据更新操作和执行缓存更新操作的请求，都通过nginx服务器路由到相同的服务实例上。



缓存为空，可能有2种情况：

1.  根本没有改数据，可以通过 判断队列中有没有数据更新操作

   如果没有，那么该数据压根儿没有，不用停顿，直接返回空值

   如果有，那么停顿一会等待更新数据库操作完成后更新缓存后再返回

2. 



经典的缓存+数据库的读写模式 cache aside pattern

(1) 读的时候先读缓存，有直接返回；没有则读数据库，填充缓存，然后返回；

(2) 更新数据的时候，先删缓存，再更新数据库。



28法则，黄金法则：20%的数据占用了80%的访问量。



问题：

1.为什么删除缓存而不是更新缓存？

1.1 缓存有的时候不是从数据库中直接取出来的，而是经过业务计算的结果

​	   更新缓存代价高昂

1.2 缓存不一定被频繁的访问

​		一个涉及缓存的表字段，1分钟更新了 20次，但是只 读取了一次，很不划算。

​	   删除缓存而不是更新缓存其实是一个懒加载的思想，需要的时候重新计算一次即可。

2.为什么先删缓存？

​		因为最终以数据库为准，而查询时缓存在数据库前面拦截了一次，会脏读。

